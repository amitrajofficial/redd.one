---
id: 35db4a2a-0750-4699-a405-3996a6d99a99
date: 2020-12-12
category: Engineering
title: 'Thinking in Functions, Part II: Higher-order functions'
description: Understanding and knowing how higher-order functions work is the essential skill of any software engineer. Let's take a dive into what a higher-order function is, and how to apply them in your everyday life.
image: ./thumbnail.jpg
---

In the [previous article](/blog/thinking-in-functions) we have uncovered the importance and usefulness of the "input/output" pattern when writing functions. Today I'd like to continue the topic and talk about one of the most powerful concepts of functional programming—higher-order function.

---

## Higher-order function

_Higher order function_ is a function that accepts another function as an argument, or returns a function. Or both.

Here's an example of a higher-order function:

```js
// Function `fn` accepts function `a` as an argument,
function fn(a) {
  // ...and calls it with `x` to get the value of `y`.
  const y = a(x)
}
```

While that example is rather abstract, there are other illustrations of higher-order functions that you may already be using on a daily basis. In JavaScript a lot of prototype methods of native classes are higher-order functions. Such methods include:

- [`Array.prototype.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`Array.prototype.find`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [`Array.prototype.reduce`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

All those functions accept another function as an argument and that makes them higher-order functions. Let's analyze what that means taking `Array.prototype.map` as an example:

```js
const numbers = [1, 2, 3]

// Go through each number in the `numbers` array
// and multiple it by 2.
numbers.map((number) => number * 2) // [2, 4, 6]
```

You are familiar that the `map` function goes through each array memeber and executes some logic on it. That very logic is described in another function that the `map` accepts, and not in the `map` istelf. This means we can define any action and pass it to `map`, which, in turn, guarantees to call our function on each array memeber iteration.

<Quote>
  Higher-order function encapsulates certain behavior, leaving the other
  behavior to the function they accept as an argument.
</Quote>

The contract a higher-order function establishes is true on the given terms:

- A higher-order function is in charge when to call a passed function;
- A higher-ordef function is in charge what argument a passed function accepts.

To better understand this concept, let's build our own `map` function.

```js focusedLines=8-10
function map(arr, mapper) {
  let result = []

  for (let i = 0; i < arr.length; i++) {
    // Get the current array member by index.
    const member = arr[i]

    // Call the `mapper` function we accept as an argument,
    // and provide the current array member to it.
    const mappedValue = mapper(member)

    // Push the result of the `mapper` function
    // into the end array of transformed members.
    result.push(mappedValue)
  }

  return result
}
```

Our custom `map` function could be used like so:

```js
map([1, 2, 3], (number) => number * 2)
// Identical to:
// [1, 2, 3].map((number) => number * 2)
```

You can see that the iteration details, like the `for` cycle and the internal `results` array, that are not exposed to the `mapper` function, and our custom `map` function controls precisely when to call the given `mapper` argument and what data to provide it:

```js lineNumberStart=10
const mappedValue = mapper(member)
```

<Quote>
  Higher-order function controls when to call an argument function, and what
  data to provide it.
</Quote>

The point of our `map` function is that it can do much more than multiplication of numbers. In fact, as it accepts a function that controls what to do with each array member, I dare say our `map` function can do _anything_.

```js showLineNumbers=false
map(['hello', 'world'], (word) => word.toUpperCase())
```

A concept of a higher-order function is far more powerful than tranforming array members. It's more about delegating an action (i.e. `(number) => number * 2`) to a different execution context.

### Returning a function

A higher-order function may also return a function. Let's use the same `map` utility we've created, but now rewrite it to return a function.

```js focusedLines=1-4
// Instead of accepting the array on the top level,
function map(mapper) {
  // ...we return a function that accepts that array.
  return (arr) => {
    let result = []

    // ...leaving the iteration logic as-is.
    for (let i = 0; i < arr.length; i++) {
      const member = arr[i]
      const mappedValue = mapper(member)
      result.push(mappedValue)
    }

    return result
  }
}
```

Since the `map` no longer accepts two argument, but one, calling it becomes slightly different:

```js showLineNumbers=false
map((number) => number * 2)([1, 2, 3])
```

The `fn(x)(y)` call signature is not common in JavaScript. Moreover, it's plain confusing. If you break down this function call into two separate functions, you will notice things getting a little more clear.

```js
// Calling `map` now returns a new function.
const multiplyByTwo = map((number) => number * 2)

// That returned function already knows it should
// multiply each array member by 2.
// Now we only call it with the actual array.
multiplyByTwo([1, 2, 3]) // [2, 4, 6]

// We can reuse the `multiplyByTwo` function
// without having to repeat what it does,
// only changing a data it gets.
multiplyByTwo([4, 5, 6]) // [8, 10, 12]
```

Our `map` function no longer does anything by itself, yet it _generates_ another function that remembers what transformations it should do, and returns it to be called with the actual data some time later.

> TODO Elaborate on the HOF returning a function.

---

## Application

> TODO Showcase practical usage examples and pieces of advice.

A higher-order function is a good choice when you need to delegate logic to a different context.

### Declarative

With higher-order function you often encapsulate imperative repetitive logic ...

### Abstract

It helps to reason about the code in a more abstract way. Consider these two code snippets:

```js
const letters = ['a', 'b', 'c']
const nextLetters = []

for (let i = 0; i < letters.length; i++) {
  const letter = letters[i]
  nextLetters.push(letter.toUpperCase())
}
```

```js
const letters = ['a', 'b', 'c']
const toUpperCase = (letter) => letter.toUpperCase()
const nextLetters = map(letters, toUpperCase)
```

It's not about the amount of code, but about how easy that code is to read and understand. It's also about reusing and composing—creating new logic by combining existing functions. Take a look at how the abstractions below give you an idea of what's happening without you peaking into their implementation details:

```js
map(ids, toUserDetail)
map(users, toPosts)
reduce(posts, toTotalLikes)
```

### Fundamental

Higher-order functions are fundemental to _partial application_ and _currying_—two techiniques that are irreplaceable in functional programming. These may sound like foreign words to you, but don't worry, we are going to cover them in the next part of these series.

## Creating a higher-order function

Just as with any other function, applying the [Input/Output pattern](/blog/thinking-in-functions) is a great place to start when declaring a higher-order function. With that, there are a few additional questions to ask yourself:

1. What action is being delegated to the argument function?
1. When should the argument function be called?
1. What data is provided to the argument function?
1. Does the returned data of the argument function affects the parent function?

It's crucial to establish a clear separation between the responsibilities of a higher-order function and the argument function it accepts.

> **Exercise:** Try to write your own `filter()` function: it accepts an array and a function to filter its members, returning a filtered array. The same way as [`Array.prototype.filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) behaves. Refer to the `map` function we've created in this article for help.

---

## Real-life example

While working on one of my projects, I've decided to create a custom function that would allow me to handle an [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) instance as a Promise. The intention was to make such requests declaration shorter and support the `async/await` syntax. I've started by creating a helper function:

```js
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.open(options.method, options.url)

  return new Promise((resolve, reject) => {
    req.addEventListener('load', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
    req.send()
  })
}
```

I would then use that `createXHR` function in my tests like this:

```js
test('handles an HTTPS GET request', async () => {
  const res = await createXHR({
    method: 'GET',
    url: 'https://test.server',
  })
})
```

Thing is, I also needed for various testing scenarios to configure a request differently: set headers, send request body, or attach event listeners. To support that, I went to my `createXHR` function and extended its logic:

```js focusedLines=3,5-9,11,15
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.responseType = options.responseType || 'text'

  if (options?.headers) {
    Object.entries(options.headers).forEach([header, value] => {
      req.setRequestHeader(header, value)
    })
  }

  req.addEventListener('error', options.onError)

  return new Promise((resolve, reject) => {
    // ...
    req.send(options.body)
  })
}
```

As the test scenarios grew in diversity, my `createXHR` function grew in complexity. It resulted in an overly complex function that was hard to read and even harder to use. Why did that happen?

My mistake was to assume that the `createXHR` function should configure a request on its own. Describing a request configuration as the `options` object wasn't a sound choice either, as object is a finite data structure and cannot represent all the variety of how a request can be declared.

Instead, my helper function should have allowed for each individual call to configure a request instance it needs. And it could do that by becoming a higher-order function and accepting an action that configures a request instance as an argument.

```js focusedLines=1-2,5-6
// Accept a `middleware` function,
function createXHR(middleware) {
  const req = new XMLHttpRequest()

  // ...that configures the given `XMLHttpRequest` instance,
  middleware(req)

  // ...and still promisifies its execution.
  return new Promise((resolve, reject) => {
    req.addEventListener('loadend', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
  })
}
```

> The reason `XMLHttpRequest` instance is declared within the function and not accepted as an argument is because you cannot change certain options once a request has been sent.

Notice how cleaner that function becomes as it delegates the request configuration to a `middleware` function. With that, each test can provide its own way to set up a request and still receive a Promise in return.

```js focusedLines=3-5,11-13
test('submits a new blog post', async () => {
  const req = await createXHR((req) => {
    req.open('POST', '/posts')
    req.setRequestHeader('Content-Type', 'application/json')
    req.send(JSON.stringify({ title: 'Thinking in functions', part: 2 }))
  })
})

test('handles error gracefully', async () => {
  const req = await createXHR((req) => {
    req.open('GET', '/posts/thinking-in-functions')
    req.addEventListener('error', handleError)
    req.send()
  })
})
```

---

## Afterword

High-order function may be a hard concept to grasp at first, but give it some time, apply it on practice, and the understanding will come. It's a crucial part of functional programming and a great step to start thinking in functions. I hope this article has contributed to your knowledge and you feel an extra tool in your arsenal now.
