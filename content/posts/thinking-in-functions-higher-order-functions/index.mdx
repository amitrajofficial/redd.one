---
category: Engineering
date: 2020-12-12
title: 'Thinking in Functions, Part II: Higher-order functions'
description: Understanding and knowing how higher-order functions work is the essential skill of any software engineer. Let's take a dive into what a higher-order function is, and how to write those in your everyday life.
image: ./thumbnail.jpg
---

In the [previous session](/blog/thinking-in-functions) we have uncovered the importance and usefulness of the "input/output" pattern when writing functions. Today I'd like to continue the topic with one of the most useful and powerful concepts when it comes to designing functionsâ€”high order function.

---

## Higher-order function

_Higher order function_ is a function that accepts another function as an argument, or returns a function. Or both.

Here's an example of a higher-order function:

```js
// Function `a` accepts function `b` as an argument,
function a(b) {
  // and calls it with `x` to get the value of `y`.
  const y = b(x)
}
```

While that example is rather abstract, there are other illustrations of higher-order functions that you may already be using on a daily basis. In JavaScript a lot of prototype methods of native classes are higher-order functions. Such methods include:

- [`Array.prototype.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- [`Array.prototype.find`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [`Array.prototype.reduce`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

All those functions accept another function as an argument and that makes them higher-order functions. Let's analyze what that means taking `Array.prototype.map` as an example:

```js
const numbers = [1, 2, 3]

// Go through each number in the `numbers` array
// and multiple it by 2.
numbers.map((number) => number * 2) // [2, 4, 6]
```

You are familiar that the `map` function goes through each array memeber and executes some logic on it. That very logic is described in another function that the `map` accepts, and not in the `map` istelf. This means we can define any action and pass it to `map`, which, in turn, guarantees to call our function on each array memeber iteration.

<Quote>
  Higher-order function encapsulates certain behavior, leaving the other
  behavior to the function they accept as an argument.
</Quote>

The contract a higher-order function establishes is true on the given terms:

- A higher-order function is in charge when to call a passed function;
- A higher-ordef function is in charge what argument a passed function accepts.

To better understand this concept, let's build our own `map` function.

```js focusedLines=8-10
function map(arr, mapper) {
  let result = []

  for (let i = 0; i < arr.length; i++) {
    // Get the current array member by index.
    const member = arr[i]

    // Call the `mapper` function we accept as an argument,
    // and provide the current array member to it.
    const mappedValue = mapper(member)

    // Push the result of the `mapper` function
    // into the end array of transformed members.
    result.push(mappedValue)
  }

  return result
}
```

Our custom `map` function could be used like so:

```js
map([1, 2, 3], (number) => number * 2)
// Identical to:
// [1, 2, 3].map((number) => number * 2)
```

You can see that the iteration details, like the `for` cycle and the internal `results` array, that are not exposed to the `mapper` function, and our custom `map` function controls precisely when to call the given `mapper` argument and what data to provide it:

```js lineNumberStart=10
const mappedValue = mapper(member)
```

<Quote>
  Higher-order function controls when to call an argument function, and what
  data to provide it.
</Quote>

The point of our `map` function is that it can do much more than multiplication of numbers. In fact, as it accepts a function that controls what to do with each array member, I dare say our `map` function can do _anything_.

```js showLineNumbers=false
map(['hello', 'world'], (word) => word.toUpperCase())
```

A concept of a higher-order function is far more powerful than tranforming array members. It's more about delegating an action (i.e. `number => number * 2`) to a different execution context.

### Returning a function

A higher-order function may not accept a function as an argument, but return a function. Let's use the same `map` function we've created, but now we will rewrite it to return a function.

```js
// Instead of accepting the array on the top level,
function map(mapper) {
  // ...we return a function that accepts that array.
  return (arr) => {
    let result = []

    // ...leaving the other logic intact.
    for (let i = 0; i < arr.length; i++) {
      const member = arr[i]
      const mappedValue = mapper(member)
      result.push(mappedValue)
    }

    return result
  }
}
```

As the `map` function no longer accepts two arguments and returns a new function, calling it would be slightly different:

```js
map((number) => number * 2)([1, 2, 3])
```

The `a(x)(y)` call signature is not common in JavaScript. Moreover, it's plain confusing. If you break down this function call into two separate functions, you will notice how things get a little more clear.

```js
// Calling `map` now returns a new function.
const multiplyByTwo = map((number) => number * 2)

// Calling the returned function already knows
// that it should multiply each array member by 2.
// Now we only provide the actual array to it.
multipleByTwo([1, 2, 3])

// We can reuse the `multipleByTwo` function
// without having to describe what to do with
// array members each time we use it.
multipleByTwo([4, 5, 6])
```

Our `map` function no longer does anything by itself, yet it _generates_ and returns another function that would apply the transformations given to `map`.

## When should I use?

---

## Real-life example

While improving one of my projects, I've decided to create a custom function that would allow me to handle an [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest) instance as a Promise. The intention was to make such requests declaration shorter and support the `async/await` syntax. Without hesitation, I've created a helper function:

```js
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.open(options.method, options.url)

  return new Promise((resolve, reject) => {
    req.addEventListener('load', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
    req.send()
  })
}
```

I would then use that `createXHR` function in my tests like this:

```js
test('handles an HTTPS GET request', async () => {
  const res = await createXHR({
    method: 'GET',
    url: 'https://test.server',
  })
})
```

Thing is, I also needed for various testing scenarios to configure a request differently: set headers, send request body, or attach event listeners. To support that, I went to my `createXHR` function again and extended its logic:

```js focusedLines=3,5-9,11,15
function createXHR(options) {
  const req = new XMLHttpRequest()
  req.responseType = options.responseType || 'text'

  if (options?.headers) {
    Object.entries(options.headers).forEach([header, value] => {
      req.setRequestHeader(header, value)
    })
  }

  req.addEventListener('error', options.onError)

  return new Promise((resolve, reject) => {
    // ...
    req.send(options.body)
  })
}
```

As the test scenarios grew in diversity, my `createXHR` function grew in complexity. It resulted in an overly complex function that was hard to read through, and even harder to use properly. Why did that happen?

My mistake was to assume that the `createXHR` function should configure a request. Representing request configuration as the `options` object wasn't a sound choice either, as object is a finite data structure and cannot represent all the variativity of request declaration.

Instead, my abstraction should have allowed for each individual call to configure a request instance it needs. And it can do that by becoming a higher-order function and accepting an action that configures a request instance.

```js focusedLines=2,6
// Accept a `middleware` function,
function createXHR(middleware) {
  const req = new XMLHttpRequest()

  // that configures the given `XMLHttpRequest` instance,
  middleware(req)

  // and still promisifies its execution.
  return new Promise((resolve, reject) => {
    req.addEventListener('loadend', resolve)
    req.addEventListener('abort', reject)
    req.addEventListener('error', reject)
  })
}
```

> The reason `XMLHttpRequest` instance is declared within the function and not accepted as an argument is because you cannot change certain request options after it has been sent.

Notice how cleaner that function becomes as it delegates the request configuration to a `middleware` function. With that, each test can provide its own way to set up a request and still receive a Promise in return.

```js
test('submits a new blog post', async () => {
  const req = await createXHR((req) => {
    req.open('POST', '/posts')
    req.setRequestHeader('Content-Type', 'application/json')
    req.send(JSON.stringify({ title: 'Thinking in functions', part: 2 }))
  })
})

test('handles error gracefully', async () => {
  const req = await createXHR((req) => {
    req.open('GET', '/posts/thinking-in-functions')
    req.addEventListener('error', handleError)
    req.send()
  })
})
```

---

## Afterword

Higher-order function is a hard concept to distribute responsibily and complexity in the functions you create. I hope this article provided a sufficient point for you to start noticing when a logic can be abstracted into a function and accepted as an argument. Stay productive!
